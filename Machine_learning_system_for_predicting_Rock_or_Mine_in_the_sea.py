# -*- coding: utf-8 -*-
"""Completed copy of Rock vs Mine Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Oz6huUzqFXvF_oTfNCw5qq9fw5YEFF4e

Importing Dependencies
"""

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

"""Data collection and data Processing"""

# Loading the data set through the pandas data frame

sonar_data = pd.read_csv('/content/Copy_of_sonar_data.csv', header=None)

sonar_data.head()

"""Number of rows and column"""

sonar_data.shape

"""This gives you the statistical meaning of your data
the counts tells you the number of instances for each column

25% means 25% of occurances in the column are less than 0.013350
"""

sonar_data.describe()

"""Let's count the number of Rs and Mines (M) . we included [60] because we want the search to be done in the colomun number 60

SO our prediction will be good with a strong model if we have almost same number of M and R . 111 AND 97 is not enough , we may require 1000s and 10000s to get a strong model
"""

sonar_data[60].value_counts()

"""M --> Mines

R --> Rocks

Let's group the data by the content of column [60] that R and M
"""

sonar_data.groupby(60).mean()

"""Let's now seperate the data into X and Y

"""

X = sonar_data.drop(columns=60, axis=1)
# if you are referring to the column u must specify axis=1 or axis = 0  for row
Y = sonar_data[60]
# this stores only the 60th column in Y

print(X)
print(Y)

"""Splitting the data into training and test data"""

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size= 0.1, stratify=Y, random_state=1)

print(X.shape, X_train.shape, X_test.shape)

print(Y.shape, Y_train.shape, Y_test.shape)

"""Model training
we will be using a Logistic Regression model , because it works fine with binomial predictions like Rock or Mine | fake or real
"""

model = LogisticRegression()

"""Train the logistic Regression model with the training data"""

model.fit(X_train, Y_train)

"""Model Evaluation
fiiding the Accuracy


let's find accuracy on the training data first
"""

X_train_prediction = model.predict(X_train)

trainining_data_accuracy = accuracy_score(X_train_prediction, Y_train)

print(trainining_data_accuracy)

"""accuracy on test data

"""

X_test_prediction = model.predict(X_test)
test_data_accuracy = accuracy_score(X_test_prediction, Y_test)

print('Accuracy on test data: ', test_data_accuracy)

"""#Making a Predictive system


"""

input_data = (0.0001,0.0351,0.0030,0.0304,0.0339,0.0860,0.1738,0.1351,0.1063,0.0347,0.0575,0.1112,0.2274,0.4038,0.5223,0.6847,0.7521,0.7760,0.7708,0.8627,1.0000,0.8873,0.8057,0.8760,0.9066,0.9430,0.8846,0.6500,0.2970,0.2423,0.2992,0.1185,0.2277,0.1529,0.1037,0.0352,0.2055,0.1373,0.1331,0.1454,0.1115,0.0440,0.0762,0.1381,0.0831,0.0654,0.0844,0.0595,0.0111,0.0313,0.0154,0.0106,0.0097,0.0022,0.0001,0.0072,0.0056,0.0038,0.0043,0.0030)

#Changing the input data into a numpy array

input_data_as_numpy_array = np.asarray(input_data)

#Reshape the np array as we are predicting for one instance

input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

prediction = model.predict(input_data_reshaped)

print(prediction)


if(prediction[0] == 'R'):
  print('the object is a Rock')
else:
  print('The Object is Mine')
